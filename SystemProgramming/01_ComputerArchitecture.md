# ComputerScience

## System Programming

### 컴퓨터 구조의 기본

시스템 프로그래밍이란?

- `컴퓨터 시스템을 동작시키는 프로그램`
- 컴퓨터 시스템 = 하드웨어 + 운영체제 이러한 프로그램 작성을 위한 라이브러리는 Windows 운영체제에 의해 제공 된다.

## 컴퓨터 시스템의 주요 구성 요소

1. CPU → 컴퓨터 구조 (Computer Architecture)
2. 캐쉬(Cache) → 컴퓨터 구조 (Computer Architecture)
3. 메인 메모리 → 운영체제 (Operating System)
4. 하드 디스크 → 운영체제 (Operating System)

## 컴퓨터 하드웨어의 구성

1. CPU(Central Processing Unit)
    
    > 중앙 처리 장치
    1. ALU(Arithmetic Logic Unit)
        1. 실제 연산을 담당하는 블록
        2. 기본적인 연산은 덧셈, 뺄셈, AND, OR와 같은 연산이다. (산술 연산과 논리 연산)
    2. 컨트롤 유닛
        1. 명령어를 해석하고, 그 해석된 결과에 따라서 적절한 신호를 다른 CPU블록에 보내는 역할을 한다.
        2. `10011010 0011010` 등으로 명령이 요청될 때 ALU는 논리 연산과 산술연산밖에 할줄 모른다. 이를 컨틀롤 유닛이 구분하고 ALU에게 신호를 보낸다.
    3. Register Set
        1. 예를 들어 ALU가 작업 중이어서 다음 작업을 처리하지 못할 때 CPU 내부에 임시적으로 데이터를 저장하기 위한 조그마한 메모리 공간이 필요하다.
        2. 이 메모리 공간이 **Register**이다. 
        3. 레지스터는 2진 데이터(Binary Data) 저장을 위한 저장장치이다.
    4. Bus Interface
        1. CPU, RAM, Hard disk, sound card등이 데이터를 주고 받기 위해서 어떠한 매개체가 있어야 하는 데 이것이 I/O 버스이다.
        2. I/O 버스의 통신 방식을 이해하고 있어야만, 데이터를 주고 받을 수 있는 데, **CPU 내에서는 I/O 버스의 통신방식을 이해하고 있는 그 무엇인가가 있어야만 한다.**
        3. 데이터 전송에 따른 프로토콜, 통신방식을 이해하고 있는 녀석이 바로 Bus Interface이다.
    - 번외: 클럭 신호(Clock Pulse)
        - 클럭 신호는 타이밍을 제공하기 위해서 필요한 것.
        - 가령 예를 들어 CPU 1.6Mhz 이면 1초에 1,600,000번 클럭을 발생시키고 이 클럭에 맞춰서 일을 한다.
        - 그런데 왜? 클럭신호에 맞춰서만 일을 할까? 그냥 되는대로 열심히 일하면 더 성능이 좋아질텐데 말이다.
        - 예를 들어) 연산 장치 - 버퍼 - 출력장치가 있을 때, 연산장치의 input으로 계속해서 값이 들어올 때, 연산 장치의 연산 속도와 출력장치의 데이터를 가져가는 속도가 다르다고 하면 문제가 발생한다.
        - 만약 출력장치가 더 빠르다면 출력장치는 이미 가져간 데이터를 한번 더 가져가고,
        - 연산 장치가 더 빠르다면, 버퍼를 덮어 쓰게 되어 연산결과의 일부가 출력되지 않는 문제점이 발생하게 될것이다.
2. Main Memory
    
    > 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역 `프로그램 실행을 위해 존재하는 메모리`

3. 입 출력 버스(Input/Output Bus)
    - 컴퓨터를 구성하는 구성요소 사이에서 데이터를 주고 받기 위해 사용되는 경로이다.
    - 메인 메모리와 CPU 사이에서의 데이터 입 출력도 가능하다. 이러한 기능성을 제공하는 것이 버스 시스템이다.

## 폰 노이만의 컴퓨터 구조

> 프로그램이 컴퓨터 내부에 저장되는 구조 (Stored Program Concept)

## 프로그램 실행 과정

1. 전처리기에 의한 치환 작업
    1. #include #define과 같이 #으로 시작하는  지시자의 지시에 따라 소소코드를 적절히 변경하는 작업을 한다.
2. 컴파일러에 의한 번역
    1. 단계 1에서 번경된 소스코드는 여전히 우리가 눈으로 봐도 이해할 수 있는 내용이다.
    2. 이 소스 코드는 컴파일러에 의해서 어셈블리 코드로 번역 된다.
3. 어셈블러에 의한 바이너리 코드 생성
    1. 바이너리 코드란? 1과 0으로만 구성되는 코드를 말한다.
    2. 컴파일러에 의해 번역된 어셈블리 코드는 컴퓨터에 의해 실행되기에 앞서서 바이너리 코드로 번역되어야 한다.
    3. 사칙연산을 아래와 같이 정의한다
        
        ```cpp
        ADD 0011
        MIN 0010
        MUL 0100
        DIV 0101
        ```
        
    4. 어셈블리 프로그래밍은 아래와 같은 방식으로 프로그램을 구현한다.
        
        ```cpp
        ADD MIN MUL ADD MUL
        ```
        
        위의 코드를 어셈블러가 아래와 같이 변경한다. (어셈블러에 의한 바이너리 코드 생성)
        
        ```cpp
        0011 0010 0100 0011 0100
        ```
        
4. 링커에 의한 연결과 결합
    1. 링커의 역할 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는(혹은 연결시켜 주는) 작업을 한다.
    2. 이 과정이 끝나면 실제로 실행 가능한 실행파일이 생성된다. 물론 이 실행파일은 컴퓨터가 실행해야 하는 바이너리 코드로 구성된다.

---

## 최종 프로그램 실행과정

- 전처리기 → 컴파일러 → 어셈블러 → 링커 → 생성된 실행파일 → Load하여 메모리에 적재함
1. Fetch: 메모리에 적재 된 명령어를 CPU로 가져오는 작업을 일컫는다.
2. Decode: 가져온 명령어를 CPU가 해석하는 단계이다. 다시 말해서 무슨 일을 하는 명령어인지 분석하는 단계이다.
3. Execution: 해석된 명령어를 명령대로 CPU가 실행하는 단계이다.
- 프로그램의 기본 실행은 `Fetch, Decode, Execution` 단계를 거친다고 말할 수 있다.

---

### 고민해봐야 할 문제

1. 명령어 실행에서 제일 먼저하는 일이 Fetch인데, 어떠한 이동경로를 통해서 명령어의 Fetch가 진행되는 것인가?
2. 명령어를 CPU안에 가져다 놓을 때, 저장하는 곳은 어디인가? (아 이거 다 컴구조할때 읽었는 데..)
3. CPU 안에 가져다 놓은 명령어는 Decode 단계에서 해석되는 데, 이는 CPU안에 존재하는 누구에 의해서 진행되는 것인가?
4. 마지막 단계인 Execution은 누구에 의해서 진행 되는가?

2번의 해답: IR (Instruction register)

3번의 해답: Control Unit ALU에게 어떤 명령을 수행해야하는지 명령어를 해석해서 신호로 알려준다.

4번의 해답: 명령의 형태에 따라서 다양하다, 데이터의 이동이 될 수도 있고 산술 논리 연산이 될 수도 있기 때문에, 산술, 논리만이라면 ALU가 정답이다.

---

### 데이터 이동의 기반이 되는 버스(BUS) 시스템

- CPU → 메모리 간의 버스 시스템
1. Data Bus: 데이터를 이동하기 위해 필요한 버스이다. 여기서 말하는 데이터란, 명령어가 될 수도 있고, 피연산자(Operand)가 될 수도 있다.
2. Address Bus: 주소값을 이동하기 위해 필요한 버스이다. 가령 예를 들어 CPU가 0x1024에 있는 데이터 4바이트를 읽으려고 한다면, 이 Address Bus를 통해서 0x1024를 전달한다. 그럼 메모리 영역의 컨트롤러가 0x1024의 4바이트 만큼 읽어서 CPU에 전달하게 된다.
3. Control Bus: CPU가 요청하는 바를 메모리에 전달할 때 사용 된다. 

[사용 예시]

```cpp
CPU: 야! 데이터 보내! //Control Bus를 통해 이동
메모리: 주소는?
CPU: 0x1200 //Address Bus를 통해 이동
메모리: 데이터 받아라 //Data Bus를 통해 이동
```